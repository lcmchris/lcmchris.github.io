<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="icon" href="../favicon.png" />
	<meta name="viewport" content="width=device-width" />
	
		<link href="../_app/immutable/assets/0.ALx6Hzrr.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.DbUL9sTe.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.BOSic6OD.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DxuXVMT6.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BBWcagcT.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DOp5pKmW.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.Bfzs4vhR.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/PPVm8Dsz.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CVL9dUfO.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/NeLHWg22.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/D0sBLIXo.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DKA5mm8m.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/D8uBHcfa.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.D0522tcJ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DC24Bgtk.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BASVQn1p.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.CP_QJfyK.js">
</head>

<body data-sveltekit-preload-data="hover">
	<div style="display: contents; "><!--[--><!--[--><!----><div class="wrapper svelte-12qhfyh"><header><nav class="svelte-8t269v"><a href="/"><h1>Chris' Log</h1></a> <a href="/about">About me</a></nav></header><!----> <main class="main-blob svelte-12qhfyh"><!----><article class="svelte-14u6r3i"><h1 style="text-align:center; font-size:24px">Alpha catan: AI from the ground up</h1> <!----><h1>Building an AI</h1> <p>For the better part of the last year, I’ve been working on a little project I called <a href="https://github.com/lcmchris/alpha-catan" rel="nofollow"><code>alpha-catan</code></a>. I wanted to work on something just fun and interesting. Nothing related to business or anything that is even (remotely) useful. Just pure unadulterated fun. The project I ended up working on is trying to build and AI that plays Catan.</p> <p>Now, Settlers of Catan is a pretty famous board game which I have personally despised for ages. Apart from the terrible experiences of fights during Catan, I strongly believe there are 2 fundamental flaws of the game.</p> <ol><li><p>Economy acceleration through luck: There is a strong economy acceleration effect. Good rolls give you resources which gives you more settlements… giving you more chances for good rolls. The <code>skill</code> is where to put your settlements. This however creates a situation where in some games you become merely an observer waiting for the winner to slowly play out the game.</p></li> <li><p>Trading: Many will argue the main game is the trading. From my experience, it is merely a tool to abuse new players. There is no reason really to trade as it is a zero-sum game. You would only accept a trade if you would increase your win% and a trade cannot do it for both parties of the trade. The only argument is if coming 2nd vs 3rd matters (which in general party games, it doesn’t).</p></li></ol> <p>These flaws are also why I believe a relatively simple model can beat the majority of players. If the only action that matters is mostly the first one, then it should be relatively simple to solve!
Armed with the <code>Hands on Machine learning book</code> and my hatred of Catan, I started working on building the model and the controller that goes with it.</p> <p>Objective: Beat average player on colonist.io</p> <h2>Building the model</h2> <p>On the outset, I wanted to do most things from scratch meaning I decided to not use a framework or any existing repos. I wanted to learn the basics of ML/RL and I got a lot of inspiration from the <a href="https://www.kaggle.com/code/scaomath/simple-neural-network-for-mnist-numpy-from-scratch" rel="nofollow">toy mnist problem with numpy</a> and <a href="https://karpathy.github.io/2016/05/31/rl/" rel="nofollow">Karpathy’s pong writeup</a>.</p> <p>The model I wanted to build is a basic one. For input game state, predict a suitable action.</p> <p>Inputs</p> <ul><li>Game state <ul><li>Players resources</li> <li>Players dev cards</li> <li>Board state</li></ul></li></ul> <p>Prediction:</p> <ul><li>Action to perform</li></ul> <p>To model multiple actions per turn, we predict until the model sets pass. This assumes that each action is the same regardless of if it is part of a chain of actions or not.</p> <p>Example: Turn</p> <ul><li>Action 1</li> <li>Action 2</li> <li>Action 3</li> <li>until… Pass</li></ul> <p>To start off with and not wanting to scale up training a lot, I focused on a 2-player rendition of the game. It is simpler letting me focus on training to win.</p> <h2>Metrics</h2> <p>The main metric I looked at is <strong>turns to win</strong>. This helps ensure that they get generically better and better. The other are standard ML metrics <strong>avg loss</strong> (indicating how close action vs prediction) and <strong>avg rewards</strong> (the number of rewards for each player).
The expectation is that <strong>turns to win</strong> trends low, <strong>avg loss</strong> trends low and <strong>avg rewards</strong> tampers to a steady level.</p> <h3>Reward allocation and the law of large numbers</h3> <p><strong>Reward allocation</strong> is a tricky business and I struggled in finding a good one. It’s essentially coming up with an intuition and then trying to build for it. For instance, the earliest edition involved only rewarding winners. This is basically running experiments!
The main difficulty comes from which action to reward. In this simple example below:</p> <p>A → B → C → D → E → Win</p> <p>… it’s unclear how much reward to allocate to each of the actions. The best reward is to reward for winning and let the model learn which actions are important. However, the longer the list of actions, the more fuzzy the allocation gets. In theory, based on the law of large numbers, it doesn’t matter (too much) but not having intermediate rewards drastically lower training speed. However, on the flip-side, overengineering the rewards would put too much human intuition to it and make it work via defined rules rather than learned rules.</p> <h4>Rewarding winners</h4> <p>The thought was the as you reward the winner’s actions, it will keep competing until it becomes the best.
Here shows the metrics:</p> <h4>Rewarding winners, Penalizing losers</h4> <p>Other than that, we could also penalize losers. This will speed up</p> <h4>Rewarding Settlements and Cities</h4> <p>Settlements and cities are pretty useful. Let’s reward them</p> <h4>Rewarding points</h4> <p>A limitation of the settlements and cities approach is that it does not reward you if you get dev cards and or longest roads etc.</p> <p>Rewarding points could be a good middle ground.</p> <h4>Training by evolution</h4> <p>An alternative to training on each player winning and losing is to train on the average winner over a batch. Although this could be slower (1/2 of rewards), it should be more accurate on which side is better, giving a better gradient.</p> <h4>Action space rebalancing</h4> <p>One thing that I noticed while training is that it overprioritised non-passing. A simple look at the action space and it’s became clear that because most actions have more than one action, passing is rarely randomly chosen. Rebalancing by a factor of the available actions looks to be a good idea. The idea here is to make passing initially the most possible action and let it slowly fall down.</p> <h2>Building the colonist.io controller</h2> <p>The colonist.io controller was much more difficult and time consuming than I thought. Because of a lack of apis to get the state of the game. The difficulty increases because colonist.io uses a html canvas to display the game. This means it’s not possible to search for elements. What I ended up having to building an image matcher in order to get the state of the game. This includes mapping each of the little settlements and city icons and use cv2 to find where it matches the most. Here is the list of all little images.</p> <p>[]</p> <p>There are essenetially many timeouts added to wait out animations. The images do not always match 100% making it also a bit unreliable.</p> <p>The canvas itself is also not the only piece of the information puzzle. The messages also need to be parsed inorder to provide additional information on whether dev cards are, what was rolled and what resources was gained.</p> <h3>Combining the two</h3> <p>Using the state gathered by the controller, I pass it to our latest and greatest model to battle it out with the colonist.io AI.</p> <p>Here’s a short video of this.</p> <p>Over 100 games… we won…</p><!----></article><!----><!----></main> <footer><nav class="svelte-178dl3j"><a href="https://github.com/lcmchris"><img class="icon svelte-178dl3j" src="/github-mark.svg" alt="GitHub"/></a> <a href="mailto:lcmchristopher@gmail.com"><img class="icon svelte-178dl3j" src="/email.svg" alt="Email"/></a> <a href="/rss.xml">RSS</a> <a href="https://follow.it/chris-l-s-blog-about-things?leanpub">Subscribe via Email</a></nav></footer><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_1dkcvhx = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.BOSic6OD.js"),
						import("../_app/immutable/entry/app.Bfzs4vhR.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
</body>

</html>